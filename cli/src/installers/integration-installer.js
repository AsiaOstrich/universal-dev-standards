import ora from 'ora';
import { copyIntegration } from '../utils/copier.js';
import {
  writeIntegrationFile,
  integrationFileExists,
  getToolFilePath
} from '../utils/integration-generator.js';
import { t } from '../i18n/messages.js';

/**
 * Integration file mappings (legacy - for fallback)
 * Maps AI tool names to their source and target file paths
 */
export const INTEGRATION_MAPPINGS = {
  cursor: {
    source: 'integrations/cursor/.cursorrules',
    target: '.cursorrules'
  },
  windsurf: {
    source: 'integrations/windsurf/.windsurfrules',
    target: '.windsurfrules'
  },
  cline: {
    source: 'integrations/cline/.clinerules',
    target: '.clinerules'
  },
  copilot: {
    source: 'integrations/github-copilot/copilot-instructions.md',
    target: '.github/copilot-instructions.md'
  },
  antigravity: {
    source: 'integrations/google-antigravity/INSTRUCTIONS.md',
    target: 'INSTRUCTIONS.md'
  },
  codex: {
    source: 'integrations/openai-codex/AGENTS.md',
    target: 'AGENTS.md'
  },
  'gemini-cli': {
    source: 'integrations/gemini-cli/GEMINI.md',
    target: 'GEMINI.md'
  },
  opencode: {
    source: 'integrations/opencode/AGENTS.md',
    target: 'AGENTS.md'
  }
};

/**
 * Install integration files for selected AI tools
 *
 * @param {Object} config - Integration installation configuration
 * @param {Array<string>} config.integrations - List of AI tool names (e.g., ['cursor', 'windsurf'])
 * @param {Object} config.integrationConfigs - Tool-specific configurations
 * @param {Array<string>} config.installedStandards - List of installed standard file names
 * @param {string} config.contentMode - Content mode ('minimal', 'index', 'full')
 * @param {number} config.level - Adoption level (1-3)
 * @param {string} config.commonLanguage - Language setting ('en', 'zh-tw', 'zh-cn', 'bilingual')
 * @param {string} config.commitLanguage - Commit message language preference
 * @param {string} projectPath - Absolute path to the project directory
 * @returns {Promise<Object>} Installation results
 * @returns {Array<string>} .integrations - List of successfully installed integration file paths
 * @returns {Array<string>} .errors - List of error messages
 * @returns {Object} .integrationBlockHashes - Hash information for UDS content blocks
 */
export async function installIntegrations(config, projectPath) {
  const {
    integrations = [],
    installedStandards = [],
    contentMode = 'minimal',
    level = 2,
  } = config;

  // Resolve parameters (support both naming conventions from different callers)
  const integrationConfigs = config.integrationConfigs || config.skillsConfig?.integrationConfigs || {};
  const commonLanguage = config.commonLanguage || config.displayLanguage || 'en';
  const commitLanguage = config.commitLanguage || config.standardOptions?.commit_language || 'english';

  const msg = t().commands.init;

  // Track results
  const results = {
    integrations: [],
    errors: [],
    integrationBlockHashes: {}
  };

  // Early return if no integrations to install
  if (integrations.length === 0) {
    return results;
  }

  // Start installation spinner
  const intSpinner = ora(msg.generatingIntegrations).start();

  // Track generated files to handle AGENTS.md sharing (codex + opencode)
  const generatedFiles = new Set();

  for (const tool of integrations) {
    // Check if this file was already generated (for AGENTS.md sharing)
    const targetFile = getToolFilePath(tool);
    if (generatedFiles.has(targetFile)) {
      // Skip - file already generated by another tool (e.g., codex generated AGENTS.md, skip opencode)
      continue;
    }

    // Build enhanced config with installed standards
    const enhancedConfig = {
      ...integrationConfigs[tool],
      tool,
      categories: integrationConfigs[tool]?.categories || ['anti-hallucination', 'commit-standards', 'code-review'],
      language: integrationConfigs[tool]?.language || commonLanguage,
      installedStandards,
      contentMode,
      level,
      // Pass commit_language for dynamic commit standards generation
      commitLanguage
    };

    // Use dynamic generator
    const result = writeIntegrationFile(tool, enhancedConfig, projectPath);
    if (result.success) {
      results.integrations.push(result.path);
      generatedFiles.add(targetFile);

      // Capture integration block hash for tracking UDS content
      if (result.blockHashInfo) {
        results.integrationBlockHashes[result.path] = {
          ...result.blockHashInfo,
          installedAt: new Date().toISOString()
        };
      }
    } else {
      // Fall back to legacy static file copy
      const mapping = INTEGRATION_MAPPINGS[tool];
      if (mapping) {
        const copyResult = await copyIntegration(mapping.source, mapping.target, projectPath);
        if (copyResult.success) {
          results.integrations.push(mapping.target);
          generatedFiles.add(targetFile);
        } else {
          results.errors.push(`${tool}: ${result.error || copyResult.error}`);
        }
      } else {
        results.errors.push(`${tool}: ${result.error}`);
      }
    }
  }

  // Update spinner with result
  const successCount = results.integrations.length;
  if (successCount > 0) {
    intSpinner.succeed(msg.generatedIntegrations.replace('{count}', successCount));
  } else {
    // intSpinner.fail(msg.failedToGenerateIntegrations || 'Failed to generate integration files');
    // Using warn instead of fail to match original behavior if at least some files failed but loop finished
    // But original code used succeed even if errors occurred, just logged errors.
    // Let's stick to succeed if loop finished, but maybe warn if 0 files generated?
    // The original code: intSpinner.succeed(msg.generatedIntegrations.replace('{count}', results.integrations.length));
    intSpinner.succeed(msg.generatedIntegrations.replace('{count}', successCount));
  }

  return results;
}

/**
 * Generate CLAUDE.md for Claude Code if selected and not already existing
 *
 * @param {Object} config - Claude Code configuration
 * @param {Array<string>} config.aiTools - List of selected AI tools
 * @param {Array<string>} config.installedStandards - List of installed standard file names
 * @param {string} config.contentMode - Content mode ('minimal', 'index', 'full')
 * @param {number} config.level - Adoption level (1-3)
 * @param {string} config.commonLanguage - Language setting ('en', 'zh-tw', 'zh-cn', 'bilingual')
 * @param {string} config.commitLanguage - Commit message language preference
 * @param {string} projectPath - Absolute path to the project directory
 * @returns {Promise<Object>} Generation results
 * @returns {string|null} .path - Path to CLAUDE.md if generated, null if skipped
 * @returns {string|null} .error - Error message if generation failed
 */
export async function generateClaudeMd(config, projectPath) {
  const {
    aiTools = [],
    installedStandards = [],
    contentMode = 'minimal',
    level = 2,
  } = config;

  // Resolve parameters (support both naming conventions from different callers)
  const commonLanguage = config.commonLanguage || config.displayLanguage || 'en';
  const commitLanguage = config.commitLanguage || config.standardOptions?.commit_language || 'english';

  const msg = t().commands.init;

  // Check if Claude Code is selected and CLAUDE.md doesn't exist
  const claudeCodeSelected = aiTools.includes('claude-code');
  if (!claudeCodeSelected || integrationFileExists('claude-code', projectPath)) {
    return { path: null, error: null };
  }

  const claudeSpinner = ora(msg.generatingClaudeMd).start();

  const claudeConfig = {
    tool: 'claude-code',
    categories: ['anti-hallucination', 'commit-standards', 'code-review'],
    languages: [],
    exclusions: [],
    customRules: [],
    detailLevel: 'standard',
    language: commonLanguage,
    // Enhanced standards compliance fields
    installedStandards,
    contentMode,
    level,
    // Pass commit_language for dynamic commit standards generation
    commitLanguage
  };

  const result = writeIntegrationFile('claude-code', claudeConfig, projectPath);
  if (result.success) {
    claudeSpinner.succeed(msg.generatedClaudeMd);
    return { path: result.path, error: null };
  } else {
    claudeSpinner.warn(msg.couldNotGenerateClaudeMd);
    return { path: null, error: result.error };
  }
}
