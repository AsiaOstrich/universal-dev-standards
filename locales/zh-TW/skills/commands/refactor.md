---
source: ../../../../skills/commands/refactor.md
source_version: 1.0.0
translation_version: 1.0.0
last_synced: 2026-01-21
status: current
description: 引導重構決策與策略選擇
allowed-tools: Read, Write, Grep, Glob, Bash(npm test:*), Bash(npx:*)
argument-hint: "[scope: tactical | strategic | legacy | decide | debt]"
status: stable
---

# /refactor 命令

> **語言**: [English](../../../../skills/commands/refactor.md) | 繁體中文

引導重構決策，推薦適合的重構策略。

## 使用方式

| 命令 | 用途 |
|------|------|
| `/refactor` | 啟動互動式重構引導 |
| `/refactor decide` | 執行重構 vs 重寫決策樹 |
| `/refactor tactical` | 建議戰術性（日常）策略 |
| `/refactor strategic` | 引導戰略性/架構重構 |
| `/refactor legacy` | 遺留程式碼安全策略 |
| `/refactor debt` | 技術債評估 |

## 工作流程

### 1. 評估階段

- 識別要重構的程式碼
- 評估測試覆蓋率
- 判定範圍（戰術/戰略）

### 2. 策略選擇

- 必要時執行決策樹
- 根據情境推薦適合的策略

### 3. 執行引導

- 提供步驟式工作流程
- 建議安全措施
- 追蹤進度

## 決策樹

執行 `/refactor decide` 時：

```
┌─────────────────────────────────────────────────────────────────┐
│              重構 vs 重寫決策樹                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 程式碼目前在生產環境運行嗎？ [Y/N]                             │
│     └─ N → 考慮重寫（風險較低）                                   │
│                                                                 │
│  2. 你了解程式碼在做什麼嗎？ [Y/N]                                │
│     └─ N → 先寫特徵測試，再決定                                   │
│                                                                 │
│  3. 測試覆蓋率 > 60%？ [Y/N]                                      │
│     └─ N → 先補測試，再決定                                       │
│                                                                 │
│  4. 核心架構可以挽救嗎？ [Y/N]                                    │
│     └─ N → Strangler Fig（漸進替換）                             │
│     └─ Y → 漸進式重構 ✓                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 策略快速參考

### 戰術性策略（日常）

| 策略 | 使用時機 |
|------|---------|
| **預備性重構** | 新增被阻擋的功能之前 |
| **童子軍規則** | 任何維護工作中 |
| **紅-綠-重構** | TDD 開發循環 |

### 戰略性策略（架構級）

| 策略 | 使用時機 |
|------|---------|
| **絞殺榕** | 替換整個系統 |
| **防腐層** | 與遺留系統整合 |
| **抽象分支** | 在主幹上重構共享程式碼 |
| **平行變更** | 變更廣泛使用的介面 |

### 安全防護策略（遺留）

| 策略 | 使用時機 |
|------|---------|
| **特徵測試** | 任何遺留程式碼重構之前 |
| **探針式重構** | 理解黑盒程式碼 |
| **找尋接縫** | 注入測試替身 |
| **Sprout/Wrap** | 在遺留程式碼中新增邏輯 |

## 範例

### 範例 1：功能被混亂程式碼阻擋

```
使用者: /refactor tactical

AI: 讓我協助你選擇戰術性重構策略。

你的情況是？
1. 功能開發被程式碼結構阻擋 → **預備性重構**
2. 在 Bug 修復中接觸程式碼 → **童子軍規則**
3. 用 TDD 撰寫新程式碼 → **紅-綠-重構**

哪個最符合你的情況？
```

### 範例 2：決策樹

```
使用者: /refactor decide

AI: 讓我協助你決定應該重構還是重寫。

**問題 1：** 程式碼目前在生產環境運行嗎？
□ 是 - 繼續下一個問題
□ 否 - 考慮重寫（沒有生產依賴，風險較低）

請回答...
```

### 範例 3：遺留程式碼

```
使用者: /refactor legacy

AI: 處理遺留程式碼需要安全優先的策略。

**在任何重構之前：**
1. ✅ 撰寫特徵測試以捕獲當前行為
2. ✅ 如果不理解程式碼，使用探針式重構
3. ✅ 找尋接縫以注入測試替身

**新增新邏輯時：**
- 使用 Sprout Method/Class 處理新功能
- 使用 Wrap Method/Class 處理前後行為

需要我協助你開始撰寫特徵測試嗎？
```

## 整合

此命令整合：

- **重構助手技能** 提供詳細引導
- **方法論系統** 追蹤重構進度
- **TDD 助手** 用於紅-綠-重構循環

## 參考

- [重構標準](../../core/refactoring-standards.md) - 核心標準
- [重構助手技能](../refactoring-assistant/SKILL.md) - 完整技能
- [TDD 助手](../tdd-assistant/SKILL.md) - TDD 工作流程

---

## 版本歷史

| 版本 | 日期 | 變更 |
|------|------|------|
| 1.0.0 | 2026-01-21 | 初始發布 |

---

## 授權

本文件以 [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) 授權發布。
