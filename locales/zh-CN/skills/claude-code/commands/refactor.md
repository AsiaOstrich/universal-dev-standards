---
source: skills/claude-code/commands/refactor.md
source_version: 1.0.0
translation_version: 1.0.0
last_synced: 2026-01-21
status: current
description: 引导重构决策与策略选择
allowed-tools: Read, Write, Grep, Glob, Bash(npm test:*), Bash(npx:*)
argument-hint: "[scope: tactical | strategic | legacy | decide | debt]"
status: stable
---

# /refactor 命令

> **语言**: [English](../../../../../skills/claude-code/commands/refactor.md) | 简体中文

引导重构决策，推荐适合的重构策略。

## 使用方式

| 命令 | 用途 |
|------|------|
| `/refactor` | 启动互动式重构引导 |
| `/refactor decide` | 执行重构 vs 重写决策树 |
| `/refactor tactical` | 建议战术性（日常）策略 |
| `/refactor strategic` | 引导战略性/架构重构 |
| `/refactor legacy` | 遗留代码安全策略 |
| `/refactor debt` | 技术债评估 |

## 工作流程

### 1. 评估阶段

- 识别要重构的代码
- 评估测试覆盖率
- 判定范围（战术/战略）

### 2. 策略选择

- 必要时执行决策树
- 根据情境推荐适合的策略

### 3. 执行引导

- 提供步骤式工作流程
- 建议安全措施
- 追踪进度

## 决策树

执行 `/refactor decide` 时：

```
┌─────────────────────────────────────────────────────────────────┐
│              重构 vs 重写决策树                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 代码目前在生产环境运行吗？ [Y/N]                               │
│     └─ N → 考虑重写（风险较低）                                   │
│                                                                 │
│  2. 你了解代码在做什么吗？ [Y/N]                                  │
│     └─ N → 先写特征测试，再决定                                   │
│                                                                 │
│  3. 测试覆盖率 > 60%？ [Y/N]                                      │
│     └─ N → 先补测试，再决定                                       │
│                                                                 │
│  4. 核心架构可以挽救吗？ [Y/N]                                    │
│     └─ N → Strangler Fig（渐进替换）                             │
│     └─ Y → 渐进式重构 ✓                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 策略快速参考

### 战术性策略（日常）

| 策略 | 使用时机 |
|------|---------|
| **预备性重构** | 新增被阻挡的功能之前 |
| **童子军规则** | 任何维护工作中 |
| **红-绿-重构** | TDD 开发循环 |

### 战略性策略（架构级）

| 策略 | 使用时机 |
|------|---------|
| **绞杀榕** | 替换整个系统 |
| **防腐层** | 与遗留系统整合 |
| **抽象分支** | 在主干上重构共享代码 |
| **平行变更** | 变更广泛使用的接口 |

### 安全防护策略（遗留）

| 策略 | 使用时机 |
|------|---------|
| **特征测试** | 任何遗留代码重构之前 |
| **探针式重构** | 理解黑盒代码 |
| **寻找接缝** | 注入测试替身 |
| **Sprout/Wrap** | 在遗留代码中新增逻辑 |

## 示例

### 示例 1：功能被混乱代码阻挡

```
用户: /refactor tactical

AI: 让我协助你选择战术性重构策略。

你的情况是？
1. 功能开发被代码结构阻挡 → **预备性重构**
2. 在 Bug 修复中接触代码 → **童子军规则**
3. 用 TDD 编写新代码 → **红-绿-重构**

哪个最符合你的情况？
```

### 示例 2：决策树

```
用户: /refactor decide

AI: 让我协助你决定应该重构还是重写。

**问题 1：** 代码目前在生产环境运行吗？
□ 是 - 继续下一个问题
□ 否 - 考虑重写（没有生产依赖，风险较低）

请回答...
```

### 示例 3：遗留代码

```
用户: /refactor legacy

AI: 处理遗留代码需要安全优先的策略。

**在任何重构之前：**
1. ✅ 编写特征测试以捕获当前行为
2. ✅ 如果不理解代码，使用探针式重构
3. ✅ 寻找接缝以注入测试替身

**新增新逻辑时：**
- 使用 Sprout Method/Class 处理新功能
- 使用 Wrap Method/Class 处理前后行为

需要我协助你开始编写特征测试吗？
```

## 整合

此命令整合：

- **重构助手技能** 提供详细引导
- **方法论系统** 追踪重构进度
- **TDD 助手** 用于红-绿-重构循环

## 参考

- [重构标准](../../../core/refactoring-standards.md) - 核心标准
- [重构助手技能](../refactoring-assistant/SKILL.md) - 完整技能
- [TDD 助手](../tdd-assistant/SKILL.md) - TDD 工作流程

---

## 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0.0 | 2026-01-21 | 初始发布 |

---

## 授权

本文档以 [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) 授权发布。
